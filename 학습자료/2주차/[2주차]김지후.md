간단한 JPA 애플리케이션을 개발해보았었다.

JPA는 Spring Data JPA와 다르게 엔티티 매니저와 엔티티 매니저 팩토리를 직접 생성해주어야 했다.

# 서론

## JPA가 제공하는 기능

- 엔티티와 테이블을 매핑하는 설계 부분
- 매핑한 엔티티를 실제 사용하는 부분

매핑한 엔티티를 엔티티 매니저를 통해 어떻게 사용하는지 알아보자.

엔티티 매니저는 엔티티를 저장, 수정, 삭제, 조회하는 등 엔티티와 관련된 모든 일을 처리한다.

개발자 입장에서 엔티티 매니저는 엔티티를 저장하는 가상의 데이터베이스로 생각하면 된다.

# 3.1 엔티티 매니저 팩토리와 엔티티 매니저

데이터베이스를 하나만 사용하는 애플리케이션은 일반적으로 EntityManagerFactory를 하나만 생성한다.

## 엔티티 매니저 팩토리 생성 코드

```java
EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabaook");
```

코드가 실행되면 persistence.xml에 있는 정보를 바탕으로 EntityManagerFactory를 생성한다.

이제, 엔티티 매니저 팩토리에서 엔티티 매니저를 생성하면 된다.

엔티티 매니저 팩토리는 엔티티 매니저를 만드는 공장이다.

엔티티 매니저 팩토리는 만들어지는 비용이 크며, 엔티티는 비용이 거의 들지 않는다.

엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 되지만, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 공유하면 안된다.

엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다.

보통 트랜잭션을 시작할 때 커넥션을 획득한다.

# 3.2 영속성 컨텍스트란?

영속성 컨텍스트란 `엔티티를 영구 저장하는 환경` 이라는 뜻이다.

영속성 컨텍스트는 JPA를 이해하는데 가장 중요하다.

엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.

```java
em.persist(member);
```

persist() 메소드는 엔티티 매니저를 사용해서 엔티티를 영속성 컨텍스트에 저장한다.

영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어진다. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있고 관리할 수 있다.

# 3.3 엔티티의 생명주기

## 엔티티 상태

- 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속 : 영속성 컨텍스트에 저장된 상태
- 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 : 삭제된 상태

# 3.4 영속성 컨텍스트의 특징

- 영속성 컨텍스트와 식별자 값
  - 영속 상태는 식별자 값이 반드시 있어야 한다. (없으면 예외 발생)
- 영속성 컨텍스트와 데이터베이스 저장
  - JPA는 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 플러시라 한다.
- 영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다.
  - 1차 캐시
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  - 지연 로딩

영속성 컨텍스트 내부에 캐시가 있는데, 이 캐시를 1차 캐시라 한다.

영속 상태의 엔티티는 모두 이곳에 저장된다.

데이터베이스에 저장되기 전에 1차 캐시에 저장한다.

즉, 데이터베이스를 조회하지 않고 메모리에 있는 1차 캐시에서 엔티티를 조회할 수 있다.

엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 차곡차곡 모아둔다. 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는데 이것을 트랜잭션을 지원하는 쓰기 지연이라 한다.

영속성 컨텍스트는 1차 캐시에 회원 엔티티를 저장하면서 동시에 회원 엔티티 정보로 등록 쿼리를 만든다. 그리고 만들어진 등록 쿼리를 쓰기 지연 SQL 저장소에 보관한다.

트랜잭션을 커밋하면 엔티티 매니저는 우선 영속성 컨텍스트를 플러시한다. 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업인데 이때 등록, 수정, 삭제한 엔티티를 데이터베이스에 반영한다. 즉, 쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 반영한다. 이렇게 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화한 후에 실제 데이터베이스 트랜잭션을 커밋한다.

# 3.5 플러시

플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.

# 3.6 준영속

영속→준영속

영속성 컨텍스트가 관리하는 영속상태의 엔티티가 영속성 컨텍스트에서 분리된 것을 준영속 상태라 한다. 따라서 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.

영속 상태였다가 더는 영속성 컨텍스트가 관리하지 않는 상태를 준영속 상태라 한다.

# 3.7 정리
