# 5장 연관관계 매핑

## 들어가며

객체의 참조와 테이블의 외래 키를 매핑하는 것이 이 장의 목표다

## 본문

연관관계 매핑을 이해하기 위한 핵심 키워드

1. 방향
    1. 단방향: 둘중 한쪽만 참조하는 것
    2. 양방향: 양쪽 모두 서로를 참조하는 것
2. 다중성
    1. 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:N) 다중성이 존재한다.
3. 연관관계의 주인
    1. 객체를 양방향 연관관계를 만들면 연관관계의 주인을 정해야한다.

## 단방향 연관관계

1. 회원과 팀이 있다.
2. 회원은 하나의 팀에만 소속될 수 있다.
3. 회원과 팀은 다대일 관계이다.

- 객체 연관관계
    - 회원 객체는 [Member.team](http://Member.team)로 팀 객체와 연관관계를 맺는다.
    - 회원 객체와 팀 객체는 단방향 관계다. 회원은 [Member.team](http://Member.team) 필드를 통해서 팀을 알 수 있지만 반대로 팀은 회원을 알 수 없다.
- 테이블 연관관계
    - 회원 테이블은 TEAM_ID 외래 키로 팀 테이블과 연관관계를 맺는다.
    - 회원 테이블과 팀 테이블은 양방향 관계다. 회원 테이블의 TEAM_ID 외래 키를 통해서 조인할 수 있고 반대로 팀과 회원도 조인할 수있다.

> 객체 연관관계와 테이블 연관관계의 가장 큰 차이
> 

 참조를 통한 연관관계는 언제나 단방향이다. 객체간에 연관관계를 양방향으로 만들고 싶으면 반대쪽에도 필드를 추가해서 참조를 보관해야한다. 결국 연관관계를 하나 더 만들어야한다. 이렇게 양쪽에서 서로 참조하는 것을 양방향 연관관계라 한다. 

정확히 이야기하면 이것은 양방향 관계가 아니라 서로 다른 단방향 관계 2개다. 반면에 테이블은 외래 키 하나로 양방향으로 조인할 수 있다.

> 객체 연관관계와 테이블 연관관계에 대한 정리
> 
- 객체는 참조로 연관관계를 맺는다.
: 참조를 사용하는 객체의 연관관계는 단방향이다. (A → B)
: 객체의 양방향 으로 참조하려면 단방향 연관관계를 2개 만들어야한다.(A→B, B→A)
- 테이블은 외래 키로 연관관계를 맺는다.
:외래 키를 사용하는 테이블의 연관관계는 양방향이다.(A JOIN B 가 가능하면 B JOIN A도 가능)

> 연관관계 매핑 어노테이션
> 
1. @ManyToOne
: 다대일(N:1)관계 매핑 정보
    
    
    | 속성 | 기능 | 기본값 |
    | --- | --- | --- |
    | optional | false로 설정하면 연관된 엔티티가 항상 있어야한다. | true |
    | fetch | 글로벌 페치 전략을 설정한다. | @ManyToone=FetchType.EAGER
    @OneToMany=FetchType.LAZY |
    | cascade | 영속성 전이기능을 사용한다. |  |
    | targetEntity | 연관된 엔티티의 타입 정보를 설정한다. 이 기능은 거의 사용하지 않음 |  |
2. @JoinColumn(name = “TEAM_ID”)
: 외래키를 매핑할 때 사용된다.
: name 속성에는 매핑할 외래 키 이름을 지정한다.
: 이 어노테이션은 생략가능하다.(기본값은 “필드명_참조하는 테이블의 기본 키 컬럼명”)
: 어노테이션 생략시 외래키를 찾을 때 기본전략을 사용한다.

| 속성 | 기능 | 기본값 |
| --- | --- | --- |
| name | 매핑할 외래 키 이름 | 필드명_참조하는 테이블의 기본 키 컬럼명 |
| referencedColumnName | 외래키가 참조하는 대상 테이블의 컬럼명 | 참조하는 테이블의 기본 키 컬럼명 |
| foreiginKey(DDL) | 외래 키 제약조건을 직접 지정할 수 있다.
이 속성은 테이블을 생성할 때만 사용한다. |  |

## 연관관계 사용

> 등록
> 

📌JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야한다.

```java
public void testSave(){
	
	Team team1 = new Team("team1", "팀1"); // 팀 1 저장
	em.persist(team1);
	
	Member member1 = new Member("member1", "멤버1");
	member1.setTeam(team1); // 연관관계 설정 member1 -> team1
	em.persist(member1);
}

// 생성된 SQL
INSERT INTO TEAM(TEAM_ID, NAME) VALUES('team1', '팀1')
INSERT INTO MEMBER(MEMBER_ID, NAME, TEAM_ID) VALUES('member1', '회원1', 'team1')
```

> 조회
> 

연관관계가 있는 엔티티를 조회하는 두 가지 방법

- 객체 그래프 탐색(객체 연관관계를 사용한 조회)
- 객체지향 쿼리 사용(JPQL)

객체 그래프 탐색

```java
//member.getTeam()을 사용해서 member와 연관된 team 엔티티를 조회할 수 있다.
Member member = em.find(Member.class, "member1");
Team team = member.getTeam() // 객체 그래프 탐색
```

객체지향 쿼리 사용

JPQL에서 연관관계를 사용하는 방법

예시. 회원을 대상으로 조회하는데 팀1에 소속된 회원만 조회하려면 회원과 연관된 팀 엔티티를 검색조건으로 사용해야된다. 

JPQL도 조인을 지원하기 때문에 아래와 같이 조회하면된다.

```java
private static void queryLogicJoin(EntityManager em)
{
	String jpql = "select m from Member m join m.team t where " + 
	"t.name = : teamname" // ":" 심볼은 파라미터 바인딩을 받는 문법이다.
	
	List<Member> resultList = em.creatQuery(jpql, Member.class)
	.setParameter("teamName", "팀1");
	.getResultList();
}

// 실행되는 SQL
SELECT M.* FROM MEMBER MEMBER
INNER JOIN
	TEAM TEAM ON MEMBER.TEAM_ID = TEAM1_.ID
WHERE
	TEAM1_.NAME='팀1'
```

> 수정
> 

수정은 단순히 불러온 엔티티의 값만 변경해두면 트랜잭션을 커밋할 때 플러시가 일어나면서 변경 감지 기능이 작동한다. 그리고 변경사항을 데이터베이스에 자동으로 반영한다.

이것은 연관관계를 수정할 때로 같은데, 참조하는 대상만 변경하면 나머지는 JPA가 자동으로 처리한다.

> 삭제
> 

```java
private static void deleteRelation(EntityManager em){
	Member member1 = em.find(Member.class, "member1");
	member1.setTeam(null); // 연관관계 제거
}

//실행되는 SQL
UPDATE MEMBER
SET
	TEAM_ID = null,...
WHERE
	ID = 'member1'
```

연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거하고 삭제해야한다. 

그렇지 않으면 외래 키 제약조건으로 인해, 데이터베이스에서 오류가 발생한다.

## 양방향 연관관계

: 연관관계의 주인

❓@OneToMany의  mappedBy는 왜 필요할까?

엄밀히 말하면 객체에서는 양방향 연관관계라는 것이 없다. 서로 다른 단방향 연관관계 2개를 애플리케이션 로직으로 잘 묶어서 양방향인 것 처럼 보이게 할 뿐이다. 

- 객체의 연관관계
    - 회원 → 팀
    - 팀 → 회원
- 테이블의 연관관계
    - 회원 ←→ 팀

테이블은 외래 키 하나로 두 테이블의 연관관계를 관리한다. 엔티티를 단방향으로 매핑하면 참조를 하나만 사용하므로 이 참조로 외래키를 관리하면된다.

그런데 엔티티를 양방향으로 매핑하면 두 곳에서 서로를 참조한다.(위 예시의 객체연관관계) 따라서 객체의 연관관계를 관리하는 포인트는 2곳으로 늘어난다.

엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래키는 하나다 따라서 두 사이에 차이가 발생한다. 

❓그렇다면 누가 외래 키를 관리 해야할까?

이런 차이로 인해 JPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래 키를 관리해야하는데 이것을 연관관계의 주인이라 한다.

양방향  연관관계 매핑 시 지켜야 할 규칙

- 두 연관관계 중 하나를 연관관계의 주인으로 정해야한다.
- 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리(등록, 수정, 삭제)할 수 있다. 반면에 주인이 아닌 쪽은 읽기만 할 수 있다.
- 주인은 `mappedBy` 속성을 사용하지 않는다.
- 주인이 아니면 `mappedBy` 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정해야한다.

> 양방향 연관관계 저장
> 

양방향 연관관계는 연관관계의 주인이 외래키를 관리한다. 따라서 주인이 아닌 방향은 값을 설정하지 않아도 데이터베이스에 외래 키 값이 정상 입력된다.

> 양방향 연관관계의 주의점
> 

연관관계의 주인만이 외래 키의 값을 변경할 수 있다. 이점을 유의해서 연관관계의 주인 값을 비우지 않도록하자.

> 연관관계 편의 메소드
> 

양방향 관계에서는 결국 양쪽 다 신경 써야 한다. 다음처럼 member.setTeam(team)과 team.getMembers().add(member)를 각각 호출하다 보면 실수로 둘 중 하나만 호출해서 양방향이 깨질 수있다. 

양방향 관계에서 두 코드는 하나인 것처럼 사용하는 것이 안전하다.

```java
public class Member {
	private Team team;
	
	public void setTeam(Team team){
		this.team = team;
		team.getMembers().add(this);
	}	

}
```

기존 관계 제거를 포함하는 리팩토링